#pragma once
//运算符
//+ ,加
//- ,减
//* ,乘
/// ,除，要求被除数不能0
//% ,取余，要求被除数不能0
//单目运算(负号)优先级最高
//&&,与，a&&b,ab同时为true，结果为true,否则false
//||，或，a||b两者,,ab同时为false，结果为false,否则true
//!,非，取反
//
//<,小于
//>,大于
//<=,小于等于
//>=,大于等于
//==,等于
//!=,不等于
//“==”和"!="两种运算符的优先级比其他关系运算符的优先级低。两个操作数只能为数字、字符、浮点数，不能用于比较两个字符串常量，因为比较的两个字符串在内存中的地址
//关系运算符的优先级比算数运算符第，x+5>y-7等于(x+5)>(y-7)

#include <iostream>

class operator_Info 
{
	void tt()
	{

		auto tt = 2 / 3;	//输出0，使用整数进行除法会带来较大误差,解决办法，使用3.0,即使用浮点数
		std::cout << tt << std::endl;
		
		//短路表达式，c++中规定,只对能够确定整个表达式值所需要的最小数目的表达式进行计算,如果计算出一个符合逻辑的表达式后，便不再进行后续判断
		//表达式1&&表达式2中，表达式1为false；表达式1||表达式2中，表达式1为true
		bool a = true;
		bool b = false;
		bool c = true;
		//这里只会计算a||b，a||b结果为true，不会计算后续的b&&c
		if ((a || b) || (b && c))
		{
		}
		//比较的对象是char字符串，则利用 int strcmp(const char s1, const char* s2),当s1 == s2时，返回值= 0；
		//要比较的对象是两个string，则利用函数compare()。若要比较string s1和s2则写为：s1.compare(s2)，若返回值为0，则两者相等。
		//比较两个string对象时是可以利用“ == ”的，相等的话，则表达式的返回值为1，不等为0
		//char[] aa="abc"，c风格字符串，==比较的是地址
		
		//比较整形是否为0,直接用==或者!=
		int anumber = 0;
		if (anumber == 0)
		{
		}
		//比较浮点，因为精度不能只用用==0
		float bnumber = 1.0;
		float delta = 0.0001; //允许的精度范围
		if ((bnumber <= delta) && (bnumber) >= delta)
		{
		}
		//条件运算，三目预算,a>b:a:b,a>b则取a的值，a<b则取b的值
		
		//位运算
		//&，与
		//^，异或，相异为true,
		//|，或
		//~,取反
		//<<,左移,相当于*2
		//>>,右移,相当于/2
		short A = 512,B,C;
		B = A << 3;//并不改变A的值
		C = 768 >> 4;
		std::cout << A;
		std::cout << B;
		std::cout << C;
	}
};



